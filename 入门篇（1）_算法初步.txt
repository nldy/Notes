1．p进制转换成10进制
int y=0,product=1;//product在循环中不断乘p，相当于p的当前位-1次方
while(x!=0){
y=y+(x%10)*product;
x=x/10;
product=product*p;
}

10进制转化成Q进制
采用除基取余法（想二进制化10进制）
int z[40],num=0;
do{
z[num++]=y%Q;	//高位z[num-1]到低位n[0]
y=y/Q;
}while(y!=0);//商不为零时循环
注：不用while是因为当y为0时，循环不执行，正确答案是0，而数组没初始化，输出就是随机数

2.排序
直接插入排序是稳定的
while(j>1 && temp < A[j-1]){	}
A[j] = temp;

注：排序题值需得到最终结果，因此直接用库函数排序节省精力，如C中qsort和C++中sort函数


结构体
struct Student {
char name[10];
char id[10];
int score;
int r;
}stu[1000];
sor函数排序：1.  分数高的排在前面
2.相同则姓名字典小的在前面
bool cmp(Student a,Student b){
if(a.score!=b.score)	return a.score>b.score;
else return strcmp(a.name,b.name)<0;//表示a的字典序小于b
}
strcmp函数是string.h下比较char型数组的字典大小，strcmp(str1,str2)等于时返回0，str1>str2返回一个正数，<返回一个负数

实现排名：分数不同排名不同，分数相同排名相同但占用一个排位
解决：在结构体定义时加入排名，遍历结构体数组，第一个（数组下标为0）排名为1，下一个分数与上一个相等，则排名相等，若分数不相等，则排名为当前数组下标加1

3.散列：用空间换时间
问题：有M和N两组数，问在M中有多少个数在N中出现
分析：若用M中每个数遍历N，那么时间复杂度为O(NM),非常大
解决：设一个数组，把输入的数作为数组下标来对比，时间复杂度O（N+M）

字符串hash
hash：唯一表达
保留余数法：H(key) = key%mod;
难点：如何将不是整数的映射成整数
处理：字符串均由字母组成，A~Z看成0~25,a~z看成26~51，他们看成52进制，这是转化成10进制肯定是唯一的。如有数字这些，继续增加进制

4.递归
分治：分而治之，将原问题划分成若干较小而结构与原问题相同的子问题，然后分别解决这些子问题，最后合并子问题的解，得到问题的解

重要概念：（1）递归边界
（2）递归式
分析问题时画递归图来思考

回溯法：在达到递归边界前的某层，由于问题条件导致不需要往任何一个子式继续递归，而可以直接返回上一层
如n皇后，在确定放了几个子后再随便放子也会冲突，就不用再递归了

5.贪心：考虑当前状态下局部最优，来使全局的结果达到最优
证明思路：使用反证法及数学归纳法，一般对问题想到似乎可行的策略，而自己无法举出反例，那么就这么实现

区间贪心
给出N个闭区间[x,y]，求最少需要多少个点，才能使每个闭区间都至少存在一个点
思路：区间排序，取端点

二分法：序列中是否存在满足某种条件的元素
求序列中第一个大于等于x的元素的位置
求序列中第一个大于x的元素的位置
return left;	//返回夹出来的位置
当while(left<=right)才循环，一次循环mid加1或减1，才有造成破处循环的可能，在这时想怎么返回是left
拓展
求根号2的近似值
快速幂（二分幂）
问题：给定3个数a,b,c，求a的b次方对c求余
for(int i=0;i<b;i++){ ans=ans*a%m; } 	
当它们次方很大时，时间复杂度O（b）就很大
思想：b是奇数，a的b次方=a*a的b-1次方 
b是偶数，a的b次方=a的b/2次方*a的b/2次方  //两数相乘减少了时间复杂度
利用递归思想，次方一直到0次方，然后依次回退，时间复杂度O（logb）


6.two pointers
倾向于一种编程技巧，提高算法效率
问题：有一个递增的正整数序列和一个正整数M，求序列中两个不同位置的数相加等于M
思想：下标i=0，下标j=n-1，i++,j--不停移动，通过a[j]+a[i]=M这个边界判断
i和j的操作次数最多为n次，时间复杂度O(n)
while(i<j){	if(a[i]+a[j]==m){	printf(“%d %d\n”,i,j);	i++;	j--;
else if(a[i]+a[j]<m) i++;//左端递增才可能从小于变等于
else j--;	}
}

应用：递增序列合并
归并排序：分成N组，不断合并，最后到只有一组就完成排序
快速排序：左右来回

7.其他技巧
打表：空间换时间
情形：（1）一次性计算出所有需要用到的结果，之后的查询直接取这些结果
（2）程序B多次计算出所需结果，写到A的数组中供A使用
如n皇后结果写在数组里
（3）对感觉不会做的题目，在小范围内暴力计算找规律

随机选择：如何在一个无序数组中求出第K大的数
执行快速排序的randPartition，主元左侧小于主元，这时判断K与主元位置，再缩小范围递归，最后找到第K大的数
int p=randpartition(a,left,right); //p为主元位置
if(k>M){ return randSelect(a,left,p-1,k); } //在主元左侧找第K大
else { return randSelect(a,p+1,right,k-M); } //右侧找第K-M大
