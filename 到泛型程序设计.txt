6、继承与派生
继承从上到下，是一个具体化、特殊化的过程
类的继承：新的类从已有类那里得到已有的特性
类的派生：已有类产生新类的过程
原有类称为基类或父类，新的类称为派生类或子类
Class 派生类名：继承方式 基类名1，继承方式 基类名2，……
{	派生类成员声明；}；
一个派生类可同时有多个基类，叫多继承
只有一个，叫单继承
直接参与派生某类的基类叫直接基类，更高层的叫间接基类
继承方式规定了如何访问基类继承成员
派生类成员：新增的

派生新类过程：吸收基类成员、改造基类成员、添加新成员
1.将基类的除构造函数和析构函数外全盘接收
2.同名隐藏
3.添加构造函数等扫尾工作

类的继承方式：public、protected、private
公有继承：基类的公有成员和保护成员访问属性在派生类中不变，而私有成员不可直接访问
私有继承：基类的公有成员和保护成员访问属性在派生类中以私有成员出现，而私有不可直接访问，基类的成员无法再在以后的派生中发挥作用，中止了基类功能继续派生
保护继承：基类的公有和保护以保护成员出现，私有不可访问。基类的保护成员可能被它的派生类访问，但决不可被其他外部使用者访问

类的兼容规则：在需要基类的地方，可以使用公有派生类的对象来替代
替代情况：1.派生类的对象隐含转换为基类对象
          2.可初始化基类的引用
          3.派生类指针可隐含转换为基类的指针
替代后只能使用基类继承的成员
Class b{……}	
class d:public b{……}	
b b1,*pb1; 		
d d1;
(1)赋值b1=d1;
(2)初始化引用 b &rb=d1;
(3）指针 pb1=&d1;


构造函数：要对基类的成员对象和新增的初始化
执行顺序：先调用基类的构造函数，再调用内嵌对象的构造函数
基类构造函数调用顺序按派生类定义时的顺序（class：后的顺序）
内嵌对象的构造函数顺序按照成员在类中声明的顺序
析构函数：默认生成

派生类中成员属性：（1）不可访问（2）私有（3）保护（4）公有

作用域分辨符::限定要访问的成员所在类的名称	类名：：成员名
要访问从基类继承的成员，必须使用（类名和作用域分辨符），使用（对象名.成员名）只能访问新增成员
d.base1::var=1;


虚基类
将共同基类设置为虚函数，从不同的路径继承过来的同名数据成员在内存中只有一个副本，同一个函数名只有一个映射
class派生类名：virtual 继承方式 基类名
此时可以使用（对象名.成员名）方式唯一标识和访问
虚基类有带形参的构造函数，继承虚基类的所有派生类都必须在构造函数中列出对虚基类的初始化

构造一个类的对象一般顺序：
（1）该类有直接或间接的虚基类，先执行虚基类的构造函数
（2）有其他基类，按照继承声明列表出现顺序，分别执行它们的构造函数，但在构造过程不在执行它们虚基类的构造函数
（3）在类中出现的顺序，对派生类中新增成员初始化。
对类类型的成员对象，出现在构造函数列表中，以指定参数执行构造函数，没有执行默认。对基本类型数据的成员对象，用指定值赋初值，没有则不管


************************************************************************************************************************************************
7.多态
多态：同样的消息被不同类型的对象接收是导致不同的行为
分类：重载多态、强制多态、包含多态、参数多态
	强制多态：将一个变元的类型加以变化，以符合一个函数或操作的要求
	包含多态：定义于不同类中同名函数成员的多态行为，通过虚函数实现
	参数多态：与类模版关联，使用时必须赋予实际的类型才可实例化
实现：编译时多态和运行时多态

运算符重载
	类关系运算符“.”、成员指针运算符“.*”、作用域运算符“：：”、三目运算符“?:”不可重载
	重载后优先级和结合性不变

虚函数
动态绑定基础
必须是非静态的成员函数
virtual 函数类型 函数（参数表）
运行过程的多态需满足条件：（1）赋值兼容（2）声明虚函数（3）由成员函数来调用或者通过指针、引用来访问虚函数
class Base1 { 	public: virtual void display() const; }	
void Base1::display() const { cout<<”base1”<<endl; }
class Base2:public Base1 { 	public: virtual void display() const; }	
void Base2::display() const { cout<<”base2”<<endl; }
class Derived:public Base2{ 	public: virtual void display() const; }	
void Derived::display() const { cout<<”Derived”<<endl; }
void fun(Base1 *ptr){	ptr->display()	}
int main(){
	Base1 base1;	Base2 base2;	Derived derived;
	fun(&base1);	fun(&base2);	fun(&derived);		return 0;
}
显示：base1
	  base2
	  derived
判定一个成员函数是否为虚函数：
	相同名称
	相同参数个数及相同的对应参数类型
	相同的返回值或满足赋值兼容规则的指针、引用型的返回值
确定是后派生类的虚函数自动覆盖基类的虚函数

纯虚函数与抽象类
抽象类是带有纯虚函数的类
纯虚函数是在基类中声明的虚函数，在基类中没有定义具体的操作内容，要求各派生类根据情况给出各自定义
virtual 函数类型 函数名（参数表）=0
注：纯虚函数没有函数体，而空的虚函数的为空；前者所在的类是抽象类，不能实例化
抽象类：通过它为类族建立一个公共的接口，更好发挥多态特性

************************************************************************************************************************************************
8.群体类
群体数据：由多个基本类型或自定义数据元素组成
分类：线性群体和非线性群体
	线性：元素按位置排列有序，分为第一个元素、第二个元素
	非：如家族族谱

1.模版工具实现参数多态化
模版函数
template<参数>
类型名　函数名(参数表)
{
函数体定义
}
模板参数可包括（１）class（或typename)标识符
　（２）“类型说明符”标识符
　（３）template<参数表>class标识符
如不同类型返回绝对值
template<typename T>
T abs(T x){
return x<0?-x:x;
}
int main(){
int n=-5;	double d=-5;
cout<<abs(n)<<endl;
cout<<abs(d)<<endl;
}

类模板：使用户可以定义一种模式，使类中的某些成员能取任意类型
template<参数>
class　类名
{
类成员声明
}
一个类模板不是一个类，它说明了类的一个家族
template<class T>
class Store{
private:
T item;
bool haveValue;
public:
Store();
T &getElem();
void putElem(const T &x);
};
template <class T>
Store<T>::Store():haveValue(false){}//默认构造函数
template<class T>	//存入数据
void Store<T>::putElem(const T &x){
haveValue=true;
item=x;
}

２．线性群体
分为直接访问、顺序访问、索引访问
直接访问：类似数组
顺序访问：类似链，只能从头到尾访问。特殊的有栈和队列

浅复制：如数组只复制了地址，没有构造自己的数组，公用一个空间操作很可能出错

************************************************************************************************************************************************
9.泛型程序设计
１．泛型程序设计：编写不依赖具体数据类型的程序
模板是主要工具
设计思想：将算法从特定的数据结构中抽象出来，使算法成为通用的、可以作用于各种不同的数据结构
概念：描述作为参数的数据类型所需具备的功能，内涵是功能，外延是有这些功能的数据类型
把具备一个概念所需要功能的数据类型称为这以概念的一个模型
可以比大小的所有数据类型记为Comparable
具有公有的复制构造函数并可用‘＝’赋值的数据类型记为Assignable

ＳＴＬ
容器：容纳、包含一组元素的对象
７中基本容器：向量(vector)、双端队列(deque)、列表（list)、集合（set）、多重集合（multiset）、映射（map）、多重映射
分为：顺序容器和关联容器（集合、映射）
迭代器：提供顺序访问容器中每个元素的方法。对迭代器使用”++“运算符获得下一个元素
指针就是一种迭代器，迭代器是泛华的指针
函数对象：一个行为类似函数的对象

２．迭代器
输入流迭代器：从一个输入流中连续地输入某种数据类型的数据,istream_iterator
输出流迭代器:ostream_iterator
//从标准输入读入多干个实数，分别将它们的平方输出
transform(istream_iterator<double>(cin),istream_iterator<double>(),ostream_iterator<double>(cout,”\t”),square);
它们可以被看作一种适配器
适配器：用于为已有对象提供新的接口的对象，一般不提供新功能，只为改变对象的接口
前向迭代器：支持数据读取和写入
　　支持对序列进行可重复的单向便利
p1==p2，++p1==++p2成立
双向迭代器：在前向的基础上支持迭代器反向移动
--p1和p1--
随机访问迭代器：在双向上支持p1+n这种，功能几乎与指针一样
迭代器区间：两个迭代器用[p1,p2)表示构成的区间，两个迭代器指向元素之间的所有元素但不包括p2指向的元素

３．容器
顺序容器
vector：支持高效的随机访问和向尾部加入新元素
将已有元素从向量容器中删除，多出的闲置空间不会被释放
所以向量容器对象的容量（capacity）大于实际有的元素个数(容器大小size)
双端队列（deque）：两端高效插入数据、支持随机访问，容器中元素分段放在一个个大小固定的数组中
删除位置越靠近中间，效率越低
列表：不能随机访问但可高效地在任意位置插入和删除元素

关联容器：每个元素都有一个键，元素按照键的取值升序排列
最大优势：高效根据键值查找容器中的一个元素
它将元素根据键的大小组织在一颗平衡二叉树中，最坏情况logn次比较

４．函数对象
ＳＴＬ定义的标准函数对象：
将具有０个、１个、２个传入参数的函数对象，分别称为产生器、一元函数、二元函数
返回值为布尔型，具有一个或两个参数称为一元谓词或二元谓词函数对象

函数适配器：将一种函数对象转化为另一种符合要求的函数对象
４类：绑定适配器、组合适配器、指针函数适配器、成员函数适配器

ＳＴＬ算法
四类：（１）不可变序列算法：不直接修改所操作的容器内容
 （２）可变序列算法：可修改内容
 （３）排序和搜索算法
 （４）数值算法：和差积



